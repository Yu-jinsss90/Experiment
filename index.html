<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Square Dodger — Deluxe</title>
<style>
  :root{
    --panel-bg: rgba(255,255,255,0.9);
    --btn-grad-1:#4facfe; --btn-grad-2:#00f2fe;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: 'Segoe UI', ui-sans-serif, system-ui, -apple-system, Roboto, Arial, sans-serif;
    background: linear-gradient(180deg,#a1c4fd,#c2e9fb);
    min-height:100vh; display:flex; align-items:center; justify-content:center;
    user-select:none; overflow:hidden;
  }
  #game-container{ position:relative; text-align:center; }
  #hud{
    position:absolute; top:-36px; left:0; right:0;
    display:flex; justify-content:space-between; gap:12px;
    font-weight:700; color:#0f172a; font-size:14px;
  }
  #hud span{ background:var(--panel-bg); padding:6px 10px; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.15); }
  canvas{
    background:#b2ebf2;
    width:360px; height:540px;   /* visible size */
    border-radius:14px; display:block; margin:auto;
    box-shadow: 0 8px 28px rgba(0,0,0,0.28);
    touch-action:none;
  }
  .menu{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    z-index:2;
  }
  .panel{
    background:var(--panel-bg); padding:22px; border-radius:20px;
    box-shadow:0 10px 26px rgba(0,0,0,0.25); text-align:center; width:min(95vw,340px);
  }
  .panel h1{ margin:0 0 10px; color:#0284c7; }
  .panel p{ margin:6px 0 14px; color:#334155; }
  .row{ display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
  .bubble-btn{
    appearance:none; border:0; border-radius:999px; padding:10px 18px;
    background:linear-gradient(145deg,var(--btn-grad-1),var(--btn-grad-2));
    color:#fff; font-size:16px; font-weight:700; cursor:pointer;
    box-shadow:0 6px 14px rgba(0,0,0,0.25); transform:translateZ(0);
    transition: transform .12s ease, filter .2s ease;
  }
  .bubble-btn:hover{ transform:scale(1.06); }
  .bubble-btn:active{ transform:scale(0.98); }
  .secondary{ background:linear-gradient(145deg,#a78bfa,#60a5fa); }
  .footer-hint{ font-size:12px; color:#64748b; margin-top:8px; }
</style>
</head>
<body>

<div id="game-container">
  <div id="hud">
    <span id="score">Score: 0</span>
    <span id="best">Best: 0</span>
    <span id="weatherLabel">Weather: —</span>
  </div>

  <canvas id="game" width="720" height="1080"></canvas> <!-- DPR-scaled internally -->

  <!-- Start Menu -->
  <div id="menuStart" class="menu">
    <div class="panel">
      <h1>Square Dodger</h1>
      <p>Dodge the red blocks. Survive to rack up points.</p>
      <div class="row" style="margin-bottom:8px;">
        <button class="bubble-btn" id="btnStart">Start Game</button>
        <button class="bubble-btn secondary" id="btnHow">How to Play</button>
      </div>
      <div class="footer-hint">Controls: ← → or A/D • Tap left/right on mobile • P to pause</div>
    </div>
  </div>

  <!-- How to Play overlay -->
  <div id="menuHow" class="menu" style="display:none;">
    <div class="panel">
      <h1>How to Play</h1>
      <p>Use the arrow keys (or A/D) to move. On mobile, tap the left/right half of the screen.</p>
      <p>The sky smoothly shifts from day to night as you score. Weather is random each run.</p>
      <div class="row">
        <button class="bubble-btn" id="btnBack">Back</button>
      </div>
    </div>
  </div>

  <!-- Death Menu -->
  <div id="menuDeath" class="menu" style="display:none;">
    <div class="panel">
      <h1>Game Over!</h1>
      <p id="finalScore">Your score: 0</p>
      <div class="row">
        <button class="bubble-btn" id="btnRetry">Try Again</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // === Canvas / DPR setup ===
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeForDPR() {
    const dpr = Math.max(1, Math.round(window.devicePixelRatio || 1));
    // Keep logical size 360x540; back buffer scaled by DPR for crispness
    const logicalW = 360, logicalH = 540;
    canvas.style.width = logicalW + 'px';
    canvas.style.height = logicalH + 'px';
    canvas.width = logicalW * dpr;
    canvas.height = logicalH * dpr;
    return { dpr, w: logicalW, h: logicalH };
  }
  let view = resizeForDPR();
  window.addEventListener('resize', () => { view = resizeForDPR(); });

  // === UI Elements ===
  const hudScore = document.getElementById('score');
  const hudBest  = document.getElementById('best');
  const weatherLabel = document.getElementById('weatherLabel');

  const menuStart = document.getElementById('menuStart');
  const menuHow   = document.getElementById('menuHow');
  const menuDeath = document.getElementById('menuDeath');
  const btnStart  = document.getElementById('btnStart');
  const btnHow    = document.getElementById('btnHow');
  const btnBack   = document.getElementById('btnBack');
  const btnRetry  = document.getElementById('btnRetry');
  const finalScore = document.getElementById('finalScore');

  btnStart.onclick = startGame;
  btnRetry.onclick = startGame;
  btnHow.onclick = () => { menuStart.style.display='none'; menuHow.style.display='flex'; };
  btnBack.onclick = () => { menuHow.style.display='none'; menuStart.style.display='flex'; };

  // === Game State ===
  let running = false, paused = false;
  let player, obstacles, score, best, keys, spawnTimer;
  let clouds, snowflakes, raindrops, lightningFlash = 0;
  let weatherType = 'clear'; // 'clear' | 'rain' | 'snow' | 'storm'
  let scorePopups = []; // {x,y,alpha,scale,value}

  best = parseInt(localStorage.getItem('square_dodger_best') || '0', 10);
  hudBest.textContent = 'Best: ' + best;

  // Player with smooth lerp movement
  function newPlayer() { return { x: 160, y: 480, size: 28, targetX: 160, lerp: 0.18 }; }

  // Inputs
  keys = {};
  document.addEventListener('keydown', e => {
    keys[e.key] = true;
    if (e.key === 'p' || e.key === 'P') togglePause();
  });
  document.addEventListener('keyup', e => { keys[e.key] = false; });

  // Touch controls
  canvas.addEventListener('touchstart', handleTouch, {passive:false});
  canvas.addEventListener('touchmove', handleTouch, {passive:false});
  canvas.addEventListener('touchend', () => { keys['ArrowLeft']=keys['ArrowRight']=false; }, {passive:false});
  function handleTouch(e){
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    const half = rect.width/2;
    keys['ArrowLeft']  = x < half;
    keys['ArrowRight'] = x >= half;
  }

  // Random helpers
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const rand = (a, b) => Math.random() * (b - a) + a;
  const ease = t => t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

  // Weather systems
  function pickWeather(){
    const types = ['clear','rain','snow','storm'];
    weatherType = types[Math.floor(Math.random()*types.length)];
    weatherLabel.textContent = 'Weather: ' + weatherType[0].toUpperCase()+weatherType.slice(1);
  }
  function initWeather(){
    clouds = []; snowflakes = []; raindrops = []; lightningFlash = 0;
    if (weatherType === 'clear' || weatherType === 'storm' || weatherType === 'rain'){
      for (let i=0;i<6;i++) clouds.push({ x: rand(-40, view.w-60), y: rand(10, view.h*0.45), w: rand(70,130), h: rand(30,50), speed: rand(0.12,0.28), alpha: rand(0.25,0.5) });
    }
    if (weatherType === 'snow'){
      for (let i=0;i<80;i++) snowflakes.push({ x: rand(0, view.w), y: rand(-view.h, view.h), r: rand(1,2.2), vy: rand(0.3,0.8), vx: rand(-0.15,0.15) });
    }
    if (weatherType === 'rain' || weatherType === 'storm'){
      for (let i=0;i<120;i++) raindrops.push({ x: rand(0, view.w), y: rand(-view.h, view.h), vy: rand(4.5,7.5), len: rand(8,14) });
    }
  }

  // Obstacles
  function spawnObstacle(){
    const w = rand(24, 60), h = rand(14, 28);
    const x = rand(4, view.w - w - 4);
    const vy = rand(2.2, 3.6);
    obstacles.push({ x, y: -h, w, h, vy });
  }

  // Score popup (Tile Hop style)
  function addScorePopup(){
    scorePopups.push({ x: view.w/2, y: view.h/2, alpha: 1, scale: 1.4, value: '+1' });
  }

  // Background sky colours (day→night as score rises)
  function skyGradient(t){ // t: 0 day -> 1 night
    const c1 = lerpColor([135,206,250],[12,20,36], t);   // top
    const c2 = lerpColor([194,233,251],[27,38,59], t);  // bottom
    const g = ctx.createLinearGradient(0,0,0,view.h);
    g.addColorStop(0, `rgb(${c1.join(',')})`);
    g.addColorStop(1, `rgb(${c2.join(',')})`);
    return g;
  }
  function lerpColor(a,b,t){ return [0,1,2].map(i=>Math.round(a[i] + (b[i]-a[i])*t)); }

  // Mountains (layered silhouettes)
  function drawMountains(t){ // t affects shade
    const shade = v => `rgb(${Math.round(50+v*20)}, ${Math.round(70+v*25)}, ${Math.round(90+v*30)})`;
    ctx.fillStyle = shade(2 - t*1.3);
    poly([[-40, view.h*0.78],[60, view.h*0.58],[150, view.h*0.76],[240, view.h*0.52],[340, view.h*0.78],[420, view.h*0.60],[460, view.h*0.78],[view.w+40, view.h*0.78],[view.w+40, view.h+40],[-40, view.h+40]]);
    ctx.fill();

    ctx.fillStyle = shade(3 - t*1.2);
    poly([[-40, view.h*0.88],[80, view.h*0.70],[170, view.h*0.86],[250, view.h*0.66],[330, view.h*0.90],[420, view.h*0.72],[500, view.h*0.90],[view.w+40, view.h*0.90],[view.w+40, view.h+40],[-40, view.h+40]]);
    ctx.fill();
  }
  function poly(points){
    const dpr = view.dpr;
    ctx.beginPath();
    ctx.moveTo(points[0][0]*dpr, points[0][1]*dpr);
    for (let i=1;i<points.length;i++) ctx.lineTo(points[i][0]*dpr, points[i][1]*dpr);
    ctx.closePath();
  }

  // Shiny block
  function drawShinyBlock(x,y,w,h,color){
    const dpr = view.dpr;
    const gx = x*dpr, gy = y*dpr, gw = w*dpr, gh = h*dpr;
    const grad = ctx.createLinearGradient(gx, gy, gx, gy+gh);
    grad.addColorStop(0, 'rgba(255,255,255,0.95)');
    grad.addColorStop(0.35, color);
    grad.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = grad;
    ctx.fillRect(gx, gy, gw, gh);
    // subtle highlight stripe
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(gx+gw*0.1, gy+gh*0.08, gw*0.8, gh*0.08);
  }

  // Clouds / Snow / Rain / Lightning draws
  function drawCloud(c){
    ctx.fillStyle = `rgba(255,255,255,${c.alpha})`;
    blob(c.x, c.y, c.w, c.h);
  }
  function blob(x,y,w,h){
    const dpr = view.dpr;
    ctx.beginPath();
    ctx.ellipse(x*dpr, y*dpr, (w/2)*dpr, (h/2)*dpr, 0, 0, Math.PI*2);
    ctx.fill();
  }
  function drawSnow(){
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    for (const s of snowflakes){
      blob(s.x, s.y, s.r*2, s.r*2);
    }
  }
  function drawRain(){
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = view.dpr*1;
    ctx.beginPath();
    for (const r of raindrops){
      const dpr = view.dpr;
      ctx.moveTo(r.x*dpr, r.y*dpr);
      ctx.lineTo((r.x-1.5)*dpr, (r.y+r.len)*dpr);
    }
    ctx.stroke();
  }
  function maybeLightning(){
    if (weatherType!=='storm') return;
    if (Math.random() < 0.004) lightningFlash = 1; // trigger
    if (lightningFlash > 0){
      ctx.fillStyle = `rgba(255,255,255,${lightningFlash*0.7})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      lightningFlash *= 0.86;
    }
  }

  // === Main loop ===
  let lastTs = 0;
  function loop(ts){
    if (!running) return;
    const dt = Math.min(32, ts - lastTs || 16);
    lastTs = ts;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  function update(dt){
    // Day→Night factor: ramp with score (0..1 over ~100 points)
    const dayNight = ease(clamp(score/100, 0, 1));

    // Weather motion
    if (weatherType==='clear' || weatherType==='rain' || weatherType==='storm'){
      for (const c of clouds){
        c.x += c.speed * dt * 0.06;
        if (c.x > view.w+50){ c.x = -c.w; c.y = rand(10, view.h*0.45); c.alpha = rand(0.25,0.5); }
      }
    }
    if (weatherType==='snow'){
      for (const s of snowflakes){
        s.y += s.vy * (dt*0.06);
        s.x += Math.sin((s.y+s.r)*0.02)*0.1 + s.vx;
        if (s.y > view.h+5){ s.y = -10; s.x = rand(0, view.w); }
        if (s.x < -5) s.x = view.w+5; if (s.x>view.w+5) s.x = -5;
      }
    }
    if (weatherType==='rain' || weatherType==='storm'){
      for (const r of raindrops){
        r.y += r.vy * (dt*0.09);
        r.x -= 0.6; // slight wind
        if (r.y > view.h+20){ r.y = -10; r.x = rand(0, view.w); }
        if (r.x < -10) r.x = view.w+10;
      }
    }

    // Player input & lerp
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.targetX -= 6;
    if (keys['ArrowRight']|| keys['d'] || keys['D']) player.targetX += 6;
    player.targetX = clamp(player.targetX, 4, view.w - player.size - 4);
    player.x += (player.targetX - player.x) * player.lerp * (dt/16);

    // Spawn obstacles
    spawnTimer -= dt;
    if (spawnTimer <= 0){
      spawnObstacle();
      // Slightly faster spawns as score rises
      const base = 620 - Math.min(300, score*2.5);
      spawnTimer = base + rand(-120, 120);
    }

    // Update obstacles
    for (let i=obstacles.length-1; i>=0; i--){
      const o = obstacles[i];
      // Slightly faster with dayNight factor (harder at night)
      const speedMul = 1 + dayNight*0.25;
      o.y += o.vy * (dt*0.11) * speedMul;
      if (o.y > view.h + 40){
        obstacles.splice(i,1);
        score++;
        hudScore.textContent = 'Score: ' + score;
        addScorePopup();
      }
    }

    // Score popups evolve
    for (let i=scorePopups.length-1; i>=0; i--){
      const p = scorePopups[i];
      p.scale += (1 - p.scale) * 0.15;
      p.alpha *= 0.93;
      if (p.alpha < 0.03) scorePopups.splice(i,1);
    }

    // Collisions
    for (const o of obstacles){
      if (player.x < o.x + o.w &&
          player.x + player.size > o.x &&
          player.y < o.y + o.h &&
          player.y + player.size > o.y){
        return gameOver();
      }
    }
  }

  function draw(){
    const dpr = view.dpr;
    const dayNight = ease(clamp(score/100, 0, 1));

    // Sky
    ctx.fillStyle = skyGradient(dayNight);
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Mountains
    drawMountains(dayNight);

    // Weather back (clouds)
    if (weatherType==='clear' || weatherType==='rain' || weatherType==='storm'){
      for (const c of clouds) drawCloud(c);
    }

    // Player & obstacles
    drawShinyBlock(player.x, player.y, player.size, player.size, '#0ea5e9');
    ctx.save();
    for (const o of obstacles) drawShinyBlock(o.x, o.y, o.w, o.h, '#ef4444');
    ctx.restore();

    // Weather front (rain/snow)
    if (weatherType==='snow') drawSnow();
    if (weatherType==='rain' || weatherType==='storm') drawRain();

    // Score popups (center)
    for (const p of scorePopups){
      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.fillStyle = '#ffffff';
      ctx.font = `${Math.round(64*dpr*p.scale)}px system-ui, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 6*dpr;
      ctx.strokeText(p.value, canvas.width/2, canvas.height/2);
      ctx.fillText(p.value, canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    // Lightning overlay (if any)
    maybeLightning();
  }

  function startGame(){
    // Reset state
    running = true; paused = false; lastTs = 0;
    player = newPlayer();
    obstacles = [];
    score = 0;
    spawnTimer = 0;
    hudScore.textContent = 'Score: 0';
    // Weather
    pickWeather();
    initWeather();

    // Menus
    menuStart.style.display='none';
    menuHow.style.display='none';
    menuDeath.style.display='none';

    // Kick loop
    view = resizeForDPR();
    requestAnimationFrame(loop);
  }

  function gameOver(){
    running = false;
    best = Math.max(best, score);
    localStorage.setItem('square_dodger_best', String(best));
    hudBest.textContent = 'Best: ' + best;
    finalScore.textContent = 'Your score: ' + score;
    menuDeath.style.display='flex';
  }

  function togglePause(){
    if (!running) return;
    paused = !paused;
    if (!paused) requestAnimationFrame(loop);
    else running = false; // stop loop; resume will call start-ish
  }

  // Initial state (show start menu)
  menuStart.style.display='flex';
})();
</script>

</body>
</html>
